// Generated by CoffeeScript 1.3.3
var abc, posture,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

posture = (function() {
  var eps;

  function posture(position, csl_mode) {
    this.isClose = __bind(this.isClose, this);
    this.position = position;
    this.csl_mode = csl_mode;
    this.edges_in = [];
    this.edges_out = [];
    this.length = 1;
  }

  eps = 0.15;

  posture.prototype.isClose = function(a, i, b, j) {
    return Math.abs(a.position[0] - b[j].position[0]) < eps && Math.abs(a.position[1] - b[j].position[1]) < eps && Math.abs(a.position[2] - b[j].position[2]) < eps;
  };

  return posture;

})();

abc = (function() {
  var MAX_UNIX_TIME, time, time2, trajectory;

  function abc() {
    this.update = __bind(this.update, this);

    this.limitCSL = __bind(this.limitCSL, this);

    this.addPostureToGraph = __bind(this.addPostureToGraph, this);

    this.newCSLMode = __bind(this.newCSLMode, this);

    this.savePosture = __bind(this.savePosture, this);

    this.detectAttractor = __bind(this.detectAttractor, this);

    this.searchSubarray = __bind(this.searchSubarray, this);

    this.toggleExplore = __bind(this.toggleExplore, this);
    this.postures = [];
    this.last_posture = null;
    this.explore_active = false;
    this.graph = arbor.ParticleSystem();
    this.graph.parameters({
      repulsion: 5000,
      stiffness: 100,
      friction: .5,
      gravity: true,
      timeout: 5,
      fps: 10
    });
    this.graph.screenPadding(20, 20, 20, 20);
    this.graph.renderer = new Renderer("#viewport");
  }

  abc.prototype.toggleExplore = function() {
    if (!physics.upper_joint.csl_active) {
      $("#toggle_csl").click();
    }
    return this.explore_active = !this.explore_active;
  };

  abc.prototype.searchSubarray = function(sub, array, cmp) {
    var found, i, j, _i, _j, _ref, _ref1;
    found = [];
    for (i = _i = 0, _ref = array.length - sub.length; _i <= _ref; i = _i += 1) {
      for (j = _j = 0, _ref1 = sub.length - 1; _j <= _ref1; j = _j += 1) {
        if (!cmp(sub, j, array, i + j)) {
          break;
        }
      }
      if (j === sub.length) {
        found.push(i);
        i = _i = i + sub.length;
      }
    }
    if (found.length === 0) {
      return false;
    } else {
      return found;
    }
  };

  MAX_UNIX_TIME = 1924988399;

  time = time2 = MAX_UNIX_TIME;

  trajectory = [];

  abc.prototype.detectAttractor = function(body, upper_joint, lower_joint) {
    var d, eps, last, p_body, p_hip, p_knee, position;
    p_body = Math.abs(body.GetAngle());
    p_hip = Math.abs(upper_joint.GetJointAngle());
    p_knee = Math.abs(lower_joint.GetJointAngle());
    if (trajectory.length === 3000) {
      trajectory.shift();
    }
    trajectory.push([p_body, p_hip, p_knee]);
    if (trajectory.length > 200 && (new Date().getTime() - time) > 2000) {
      last = trajectory.slice(-40);
      eps = 0.025;
      d = this.searchSubarray(last, trajectory, function(a, i, b, j) {
        return Math.abs(a[i][0] - b[j][0]) < eps && Math.abs(a[i][1] - b[j][1]) < eps && Math.abs(a[i][2] - b[j][2]) < eps;
      });
      if (d.length > 3) {
        position = trajectory.pop();
        this.savePosture(position, body, upper_joint, lower_joint);
        trajectory = [];
      }
      time = new Date().getTime();
    }
    if ((new Date().getTime() - time2) > 3000) {
      return time2 = new Date().getTime();
    }
  };

  abc.prototype.savePosture = function(position, body, upper_csl, lower_csl) {
    var addEdge, ctx, ctx2, f, found, i, imageData, newCanvas, p, parent, pix, x, y, _i, _ref;
    parent = this;
    addEdge = function(start_node, target_node, edge_list) {
      var n0, n1;
      if (edge_list == null) {
        edge_list = start_node.edges_out;
      }
      if (__indexOf.call(edge_list, target_node) < 0 && parent.postures.length > 1) {
        console.log("adding edge from posture " + start_node.position + " to posture: " + target_node.position);
        edge_list.push(target_node);
        n0 = start_node.position.toString();
        n1 = target_node.position.toString();
        parent.graph.addEdge(n0, n1);
        return parent.graph.getNode(n1).data.label = target_node.csl_mode;
      }
    };
    p = new posture(position, [upper_csl.csl_mode, lower_csl.csl_mode]);
    found = this.searchSubarray(p, this.postures, p.isClose);
    if (!found) {
      console.log("found new pose/attractor: " + p.position);
      this.postures.push(p);
    } else {
      f = found[0];
      p = this.postures[f];
    }
    if (this.last_posture && this.postures.length > 1) {
      addEdge(this.last_posture, p);
      ctx = $("#simulation")[0].getContext('2d');
      x = physics.body.GetWorldCenter().x * physics.debugDraw.GetDrawScale();
      y = physics.body.GetWorldCenter().y * physics.debugDraw.GetDrawScale();
      imageData = ctx.getImageData(x - 90, y - 90, 180, 180);
      pix = imageData.data;
      for (i = _i = 0, _ref = pix.length - 4; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (pix[i] === 255 && pix[i + 1] === 255 && pix[i + 2] === 255) {
          pix[i + 4] = 0;
        }
      }
      newCanvas = $("<canvas>").attr("width", imageData.width).attr("height", imageData.height)[0];
      ctx = newCanvas.getContext("2d");
      ctx.putImageData(imageData, 0, 0);
      ctx2 = $("#tempimage")[0].getContext('2d');
      ctx2.clearRect(0, 0, ctx2.canvas.width, ctx2.canvas.height);
      ctx2.scale(0.25, 0.25);
      ctx2.drawImage(newCanvas, 0, 0);
      this.graph.getNode(p.position.toString()).data.imageData = ctx2.getImageData(0, 0, ctx2.canvas.width / 8, ctx2.canvas.height / 8);
      ctx2.scale(4, 4);
    }
    this.last_posture = p;
    return this.newCSLMode();
  };

  abc.prototype.newCSLMode = function() {
    var which;
    which = Math.floor(Math.random() * 2);
    if (which) {
      return ui.set_csl_mode_upper(["r+", "r-", "c"][Math.floor(Math.random() * 2.99)]);
    } else {
      return ui.set_csl_mode_lower(["r+", "r-", "c"][Math.floor(Math.random() * 2.99)]);
    }
  };

  abc.prototype.addPostureToGraph = function(posture) {
    var get_random_color;
    return get_random_color = function() {
      var color, i, letters;
      letters = "0123456789ABCDEF".split("");
      color = "#";
      i = 0;
      while (i < 6) {
        color += letters[Math.round(Math.random() * 15)];
        i++;
      }
      return color;
    };
  };

  abc.prototype.limitCSL = function(upper_joint, lower_joint) {
    var limit, mc;
    if (upper_joint.csl_active && upper_joint.csl_mode === "c") {
      mc = upper_joint.motor_control;
      limit = 20;
      if (Math.abs(mc) > limit) {
        if (mc > limit) {
          ui.set_csl_mode_upper("r+");
          $("#gb_param_upper").val(limit);
          physics.upper_joint.gb = limit;
        } else if (mc < -limit) {
          ui.set_csl_mode_upper("r-");
          $("#gb_param_upper").val(-limit);
          physics.upper_joint.gb = -limit;
        }
        upper_joint.csl_mode = "c";
      }
    }
    if (lower_joint.csl_active && lower_joint.csl_mode === "c") {
      mc = lower_joint.motor_control;
      if (Math.abs(mc) > limit) {
        if (mc > limit) {
          ui.set_csl_mode_lower("r+");
          $("#gb_param_lower").val(limit);
          physics.lower_joint.gb = limit;
        } else if (mc < -limit) {
          ui.set_csl_mode_lower("r-");
          $("#gb_param_lower").val(-limit);
          physics.lower_joint.gb = -limit;
        }
        return lower_joint.csl_mode = "c";
      }
    }
  };

  abc.prototype.update = function(body, upper_joint, lower_joint) {
    this.limitCSL(upper_joint, lower_joint);
    if (this.explore_active) {
      return this.detectAttractor(body, upper_joint, lower_joint);
    }
  };

  return abc;

})();
