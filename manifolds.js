// Generated by CoffeeScript 1.7.1
(function() {
  var manifoldRenderer,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  manifoldRenderer = (function() {
    function manifoldRenderer() {
      this.addTrajectoryPoint = __bind(this.addTrajectoryPoint, this);
      this.initTrajectoryPoints = __bind(this.initTrajectoryPoints, this);
      this.addFixpoint = __bind(this.addFixpoint, this);
      this.initFixpoints = __bind(this.initFixpoints, this);
      this.updateCurrentState = __bind(this.updateCurrentState, this);
      this.initCurrentState = __bind(this.initCurrentState, this);
      this.init = __bind(this.init, this);
      this.animate = __bind(this.animate, this);
      this.internalToManifold = __bind(this.internalToManifold, this);
      this.createGeometry = __bind(this.createGeometry, this);
      this.scale = 3;
      this.y_offset = 7;
      this.stopStateUpdate = false;
      this.do_render = true;
    }

    manifoldRenderer.prototype.createGeometry = function(geom, data) {
      var c, i, _i, _len, _ref;
      _ref = data.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        geom.vertices.push(new THREE.Vector3(i[8] * this.scale, i[6] * this.scale - this.y_offset, i[7] * this.scale));
        c = new THREE.Color(0xff0000);
        switch (i[1]) {
          case 1:
            c.setRGB(255 / 255, 150 / 255, 0);
            break;
          case 2:
            c.setRGB(0, 195 / 255, 80 / 255);
            break;
          case 3:
            c.setRGB(0, 190 / 255, 255 / 255);
            break;
          case 4:
            c.setRGB(197 / 255, 0, 169 / 255);
        }
        geom.colors.push(c);
      }
    };

    manifoldRenderer.prototype.internalToManifold = function(configuration) {
      return {
        x: -configuration[2] * this.scale,
        y: -physics.abc.wrapAngleManifold(configuration[0]) * this.scale - this.y_offset,
        z: -configuration[1] * this.scale
      };
    };

    manifoldRenderer.prototype.animate = function() {
      if (this.do_render) {
        requestAnimationFrame(this.animate);
        this.controls.update();
        if ((typeof physics !== "undefined" && physics !== null) && (physics.body != null) && !window.stopStateUpdate) {
          this.updateCurrentState(this.internalToManifold([physics.body.GetAngle(), physics.upper_joint.GetJointAngle(), physics.lower_joint.GetJointAngle()]));
        }
        return this.renderer.render(this.scene, this.camera);
      }
    };

    manifoldRenderer.prototype.init = function() {
      var c, canvas, geometry, grp, height, hipp, i, kneep, line, line_material, p1, p2, width, _i, _ref;
      canvas = $("#webglCanvas");
      width = canvas[0].width;
      height = canvas[0].height;
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(30, width / height, 0.1, 1000);
      this.camera.position.set(-35, 10, 0);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      this.scene.add(this.camera);
      this.renderer = new THREE.WebGLRenderer({
        canvas: canvas[0]
      });
      this.renderer.setClearColor(0xffffff, 1);
      line_material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
      });
      geometry = new THREE.Geometry();
      for (i = _i = 0, _ref = semni_manifold.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        hipp = semni_manifold[i][3] - 1;
        kneep = semni_manifold[i][5] - 1;
        grp = semni_manifold[i][1];
        if (hipp > 0) {
          p1 = new THREE.Vector3(semni_manifold[i][8] * this.scale, semni_manifold[i][6] * this.scale - this.y_offset, semni_manifold[i][7] * this.scale);
          geometry.vertices.push(p1);
          p2 = new THREE.Vector3(semni_manifold[hipp][8] * this.scale, semni_manifold[hipp][6] * this.scale - this.y_offset, semni_manifold[hipp][7] * this.scale);
          geometry.vertices.push(p2);
          c = new THREE.Color(0xff0000);
          switch (grp) {
            case 1:
              c.setRGB(255 / 255, 150 / 255, 0);
              break;
            case 2:
              c.setRGB(0, 195 / 255, 80 / 255);
              break;
            case 3:
              c.setRGB(0, 190 / 255, 255 / 255);
              break;
            case 4:
              c.setRGB(197 / 255, 0, 169 / 255);
          }
          geometry.colors.push(c);
          geometry.colors.push(c);
        }
        if (kneep > 0) {
          p1 = new THREE.Vector3(semni_manifold[i][8] * this.scale, semni_manifold[i][6] * this.scale - this.y_offset, semni_manifold[i][7] * this.scale);
          geometry.vertices.push(p1);
          p2 = new THREE.Vector3(semni_manifold[kneep][8] * this.scale, semni_manifold[kneep][6] * this.scale - this.y_offset, semni_manifold[kneep][7] * this.scale);
          geometry.vertices.push(p2);
          c = new THREE.Color(0xff0000);
          switch (grp) {
            case 1:
              c.setRGB(255 / 255, 150 / 255, 0);
              break;
            case 2:
              c.setRGB(0, 195 / 255, 80 / 255);
              break;
            case 3:
              c.setRGB(0, 190 / 255, 255 / 255);
              break;
            case 4:
              c.setRGB(197 / 255, 0, 169 / 255);
          }
          geometry.colors.push(c);
          geometry.colors.push(c);
        }
      }
      line = new THREE.Line(geometry, line_material, THREE.LinePieces);
      this.scene.add(line);
      return this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    };

    manifoldRenderer.prototype.initCurrentState = function() {
      var radius, rings, segments, sphereMaterial;
      radius = 0.4;
      segments = 12;
      rings = 12;
      sphereMaterial = new THREE.MeshLambertMaterial({
        color: 0xffffff,
        opacity: 0.7,
        transparent: true
      });
      this.current_state = new THREE.Mesh(new THREE.SphereGeometry(radius, segments, rings), sphereMaterial);
      return this.scene.add(this.current_state);
    };

    manifoldRenderer.prototype.updateCurrentState = function(state) {
      if (this.do_render) {
        this.current_state.position.x = state.x;
        this.current_state.position.y = state.y;
        this.current_state.position.z = state.z;
        this.camera.lookAt(state);
        this.controls.target.x = state.x;
        this.controls.target.y = state.y;
        return this.controls.target.z = state.z;
      }
    };

    manifoldRenderer.prototype.initFixpoints = function() {
      this.fp_material = new THREE.ParticleSystemMaterial({
        size: 1.5,
        fog: true,
        vertexColors: THREE.VertexColors
      });
      return this.fixpoints = [];
    };

    manifoldRenderer.prototype.addFixpoint = function(point) {
      var geom, p, _i, _len, _ref;
      this.fixpoints.push(new THREE.Vector3(point.x, point.y, point.z));
      if (this.do_render) {
        this.scene.remove(this.fpps);
        delete this.fpps;
        geom = new THREE.Geometry();
        _ref = this.fixpoints;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          geom.vertices.push(p);
        }
        this.fpps = new THREE.ParticleSystem(geom, this.fp_material);
        return this.scene.add(this.fpps);
      }
    };

    manifoldRenderer.prototype.initTrajectoryPoints = function() {
      this.traj_material = new THREE.ParticleSystemMaterial({
        size: 0.5,
        fog: true,
        vertexColors: THREE.VertexColors
      });
      return this.trajectory = [];
    };

    manifoldRenderer.prototype.addTrajectoryPoint = function(point) {
      var c, p, _i, _len, _ref;
      this.trajectory.push(new THREE.Vector3(point.x, point.y, point.z));
      if (this.do_render) {
        delete this.traj_geom;
        this.scene.remove(this.traj_ps);
        delete this.traj_ps;
        this.traj_geom = new THREE.Geometry();
        _ref = this.trajectory;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          this.traj_geom.vertices.push(p);
          c = new THREE.Color(0x7f7f7f);
          this.traj_geom.colors.push(c);
        }
        this.traj_ps = new THREE.ParticleSystem(this.traj_geom, this.traj_material);
        return this.scene.add(this.traj_ps);
      }
    };

    return manifoldRenderer;

  })();

  if (window.simni == null) {
    window.simni = {};
  }

  window.simni.ManifoldRenderer = manifoldRenderer;

  $(document).ready(function() {
    manifoldRenderer = new manifoldRenderer;
    manifoldRenderer.init();
    if (typeof physics !== "undefined" && physics !== null) {
      manifoldRenderer.initCurrentState();
      manifoldRenderer.initTrajectoryPoints();
      manifoldRenderer.initFixpoints();
    }
    manifoldRenderer.animate();
    return window.manifoldRenderer = manifoldRenderer;
  });

}).call(this);

//# sourceMappingURL=manifolds.map
